#!/usr/bin/env bash

# MIT license (c) 2024 https://github.com/slowpeek
# Homepage: https://github.com/slowpeek/ifempty
# About: Data protection wrapper for mkfs.X tools

set -eu

self=${BASH_SOURCE[0]}
name=${self##*/}

bye() {
    printf 'ifempty: %s\n' "$1" >&2
    exit 1
}

is_image() {
    [[ $1 == *.@(bin|disk|img|part|raw) ]]
}

image_or_device() {
    ! [[ -b $1 ]] || return 0

    [[ -f $1 ]] || return 1
    ! is_image "$1" || return 0
    ! is_image "$(realpath "$1")" || return 0

    return 1
}

readme() {
    cat <<'EOF'

This is a data protection wrapper for mkfs.X tools. Generally speaking, it can
be used with any tool of calling signature 'tool [options] target' where the
target is either a block device or some raw image file.

Among mkfs.X tools there are "smart" and "dumb" ones.

"Smart" tools check if the target contains something before doing anything. In
the case, some tools ask for confirmation (e.g. mkfs.ext family), while others
refuse to proceed (e.g. mkfs.xfs).

"Dumb" tools just format the target without any checks (e.g. mkfs.fat).

This script makes those "dumb" tools safer to use by emulating the "smart"
behavior.

==> Notice: Some mkfs.X tools accept an extra non-option argument: filesystem
size. This script does not support that, it assumes the last agrument is the
target.

==> Notice: Some mkfs.X tools can create the fs starting at some offset
(e.g. mkfs.fat with its --offset option). This script does not parse any
options, it just assumes the last argument is the target as-is.

Setup --

- save the script as /usr/local/bin/ifempty and make it executable
- check if /usr/local/sbin is in your PATH and overrides /usr/sbin
- in /usr/local/sbin symlink names of "dumb" tools to /usr/local/bin/ifempty

For example:

> tree /usr/local/sbin
/usr/local/sbin
├── mkfs.exfat -> /usr/local/bin/ifempty
├── mkfs.fat -> /usr/local/bin/ifempty
├── mkfs.msdos -> /usr/local/bin/ifempty
├── mkfs.ntfs -> /usr/local/bin/ifempty
├── mkfs.udf -> /usr/local/bin/ifempty
└── mkfs.vfat -> /usr/local/bin/ifempty

Check what would the shell start when one runs mkfs.fat:

> type mkfs.fat
mkfs.fat is /usr/local/sbin/mkfs.fat

So, with such setup, running mkfs.fat would start ifempty which checks the
target before passing control to the original tool.

EOF

    exit
}

tool=
while read -r path; do
    if [[ $self -ef $path ]]; then
        # Skip this script
        continue
    fi

    tool=$path
    break
done < <(type -a -p "$name")

[[ -n $tool ]] ||
    bye "Cant find other '${name}' executable in PATH"

# Pass control to the original tool right away when not on a terminal. This idea
# is borrowed from mkfs.ext family, which skips the target check on a terminal
# (search for "isatty(0)" in mke2fs.c)
[[ -t 0 && -t 1 ]] || exec "$tool" "$@"

(( $# )) || readme

last=${*: -1}

[[ -e "$last" ]] ||
    bye "'${last}' does not exist"

image_or_device "$last" ||
    bye "'${last}' is not a block device or some raw image file"

[[ -r "$last" ]] ||
    bye "'${last}' is not readable, try running with sudo"

blkid=$(blkid -o export "$last") ||
    bye "blkid cant recognize '${last}'"

msg=
while IFS='=' read -r key val; do
    case $key in
        PTTYPE)
            msg="'${last}' contains some ${val^^} partition table"
            break ;;

        TYPE)
            msg="'${last}' contains some ${val^^} superblock"
            break ;;
    esac
done <<< "$blkid"

if [[ -n $msg ]]; then
    printf '%s\n' "$msg"
    read -r -p 'Proceed anyway? (y,N) ' yn
    [[ ${yn,,} == y ]] || exit 1
fi

exec "$tool" "$@"
